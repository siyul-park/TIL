# MySQL의 쿼리최적화(Optimizer) 방법

SQL 를 최적화 과정은 일반적으로 다음 과정을 거친다



SQL 파싱

- 파싱트리 생성
- 문법적 오류 확인
- 의미상 오류 확인 (없는 컬럼, 테이블 접근)

SQL 최적화

- 옵티마이저가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 가장 최적의 실행경로로 선정

로우 소스 생성

- 선정된 실행경로를 실제 실행 가능 코드로 변경 (Row-Source Generator)가 역할 수행



쿼리 옵티마이저는 SQL 쿼리를 실행하기위한 최적의 계획을 찾는다. "좋은"계획과 "나쁜"계획 간의 성능 차이는 수십 배 (몇 초에서 몇 시간 또는 며칠)에 달할 수 있으므로 최적의 계획을 찾는것은 매우 중요한 작업이고, MySQL 쿼리를 포함한 대부분의 쿼리 옵티마이저는 최적의 검색을 위해 다소 철저한 검색을 수행한다. 가능한 모든 쿼리 평가 계획 중에서 실행 계획을 만드는데 조인 쿼리의 경우 MySQL 옵티마이저가 조사한 가능한 계획수가 쿼리에서 참조되는 테이블 수에 따라 기하 급수적으로 증가한다. 적은 수의 테이블 (일반적으로 7-10 미만)의 경우 문제가되지 않지만, 더 큰 쿼리를 제출하면 쿼리 최적화에 소요되는 시간이 서버 성능의 주요 병목이 될 수 있다. 

보다 유연한 쿼리 최적화 방법을 통해 사용자는 옵티마이저가 최적의 쿼리 평가 계획을 찾는데 얼마나 철저하게 계획을 세울지에 대해 제어 할 수 있다. 일반적으로 옵티마이저가 조사하는 계획이 적을수록 쿼리 컴파일에 소요되는 시간이 줄어 들지만, 최적의 계획을 찾지 못할 수 있다.

평가하는 계획수와 관련하여 옵티마이저의 동작은 두 가지 시스템 변수를 사용하여 제어 할 수 있다.



**optimizer_prune_level** 

옵티마이저가 각 테이블에 액세스한 행(row) 수의 추정치에 따라 특정 계획을 건너 뛰도록 지시한다. 이런 종류의 "훈련된 혹은 교육받은 가상 추정"에서 최적의 계획을 놓치지 않으며 쿼리 컴파일 시간을 크게 단축시킬 수 있다. 따라서 이 옵션은 기본적으로 켜져 있다 (optimizer_prune_level = 1). 그러나 옵티마이 저가 더 나은 쿼리 계획을 놓쳤다고 생각하면 쿼리 컴파일 시간이 더 오래 걸릴 수 있으므로 이 옵션을 끌 수 있다 (optimizer_prune_level = 0). 이 휴리스틱을 사용하더라도 옵티마이저는 여전히 대략적으로 많은 수의 계획을 탐색한다. 

**optimizer_search_depth** 

옵티마이저가 추가 확장 여부를 평가하기 위해 불완전한 각 계획의 "미래"까지의 거리를 나타낸다. optimizer_search_depth의 값이 작을수록 쿼리 컴파일 시간이 훨씬 작아질 수 있다. 예를 들어 12, 13 개 이상의 테이블이 있는 쿼리는 optimizer_search_depth가 쿼리의 테이블 수에 가까운 경우 컴파일하는데 몇 시간, 심지어 며칠이 걸릴 수 있다. 동시에, optimizer_search_depth를 3 또는 4로 컴파일하면 옵티마이저가 동일한 쿼리에 대해 1분 이내에 컴파일 할 수 있다. optimizer_search_depth에 대한 합리적인 값이 확실하지 않은 경우이 변수를 0으로 설정하여 옵티마이저가 값을 자동으로 결정하도록 지시할 수 있다.



## **옵티마이저 힌트**

옵티마이저 전략을 제어하는 한가지 방법은 optimizer_switch 시스템 변수를 설정하는 것이다. 이 변수를 변경하면 모든 후속 쿼리 실행에 영향을 준다. 한 쿼리가 다른 쿼리와 다르게 영향을 미치려면 각 쿼리전에 optimizer_switch를 변경해 한다. 

옵티마이저를 제어하는 다른 방법은 개별 명령문 내에 지정할 수 있는 옵티 마이저 힌트를 사용하는 것이다. 옵티 마이저 힌트는 명령문별로 적용되므로 optimizer_switch를 사용하여 얻을 수 있는 것보다 명령문 실행 계획을 보다 세밀하게 제어할 수 있습니다. 예를 들어, 명령문에서 한 테이블에 대한 최적화를 활성화하고 다른 테이블에 대한 최적화를 비활성화 할 수 있다. 명령문 내의 힌트는 optimizer_switch 플래그보다 우선한다.



```sql
SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1 FROM t3 WHERE f1 > 30 AND f1 < 33;
SELECT /*+ BKA(t1) NO_BKA(t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ NO_ICP(t1, t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ SEMIJOIN(FIRSTMATCH, LOOSESCAN) */ * FROM t1 ...;
EXPLAIN SELECT /*+ NO_ICP(t1) */ * FROM t1 WHERE ...;
```



## 참고

https://myinfrabox.tistory.com/92