# 컴퓨터 구조

## 가상 메모리

- 가상 메모리
  - 주 메모리를 보조 저장소의 "캐시"로 사용
  - CPU 하드웨어와 운영 체제가 공동으로 관리

- 동기 부여
  - 사용 가능한 물리적 메모리가 작음 -> 가상 주소 공간 (VAS)이 크다 
  - 연속적인 주소 공간 -> 데이터는 VAS에서만 연속되어야 함
  - 보호 -> 다른 프로세스 -> 다른 VAS
  - 공유 -> 물리적 메모리의 동일한 위치에 VAS 매핑
- 가상 메모리의 목표
  - 컴퓨터가 실제로는 비교적 작은 메인 메모리를 가지고 있음에도 불구하고 프로그래머에게 시스템에 매우 큰 메모리가 있다는 환상을 준다



### 가상 메모리 개념

- 사용자로부터 메모리의 모든 물리적 측면을 숨긴다
  - 메모리는 2KB의 논리적으로 제한되지 않은 가상 (논리적) 주소 공간
  - 가상 주소 공간의 일부만이 언제든지 실제 메모리에 존재
- 위치
  - 가상 메모리의 장점
  - 실행을 위해 프로그램로드 단순화
  - 비 연속 할당
  - 주 메모리에서 충분한 페이지 수만 찾기



### 주소 사상

- 논리적 주소 공간과 물리적 메모리 공간
- 가상 주소
  - 프로세서가 사용 (프로그램 유져)
- 물리 주소
  - 메인 메모리가 사용
- 페이지
  - 가상 메모리 블록
- 페이지 실패
  - 가상 메모리 실패



### 메모리 사상 (주소 변환)

- 가상 페이지 숫자를 물리 페이지 숫자로 바꾼다
- 하드웨어와 소프트웨어가 결합되어 실행된다



### 페이징

- 물리 메모리를 동일한 크기의 페이지 프레임으로 나눈다
  - 페이지의 크기 = 프레임의 크기
- 물리적 메모리 주소는 (f, o)의 페어이다
  - f - 프레임 번호
  - o - 프레임 오프셋



### 가상 메모리 시스템에서 주소

- 주소 = 가상 페이지 번호 || 페이지 오프셋



### 디자인 고려 사항

- 매우 큰 실패 손실 (수백만 클락)

1. 거대한 페이지 크기
   - 높은 디스크 액세스 시간을 상환 할 수있을만큼 커야한다
   - 전형적으로 4KB ~ 16KB, 최근엔 32KB 또는 64KB.
   - 새로운 임베디드 시스템에선 1KB 페이지
2. 페이지 실패율 줄이기
   - 완전 연관 방식 페이지
3. 영리한 소프트웨어 알고라즘 사용하기
   - 디스크 액세스 시간에 비해 오버 헤드가 적기 때문에
4. 나중 쓰기
   - 너무큰 디스크 쓰기 시간



### 고심

- 페이징... 고정 크기 블록
- 세그먼트화 ... 가변 크기 블록
  - 주소 = (세그먼트 번호, 오프셋)
  - 연결이 아닌 추가
  - 주소 공간에서보다 강력한 보호 및 공유 방법 지원
  - 주소 공간을 논리적으로 분리 된 부분으로 분할



### 페이지 배치 및 다시 찾기

- 완전 연관 사상
  - 페이지 배치를 최적화하여 페이지 오류율 감소
  - 가상 페이지를 모든 물리적 페이지에 매핑
- 페이지 테이블
  - 메모리를 인덱싱하는 전체 테이블
  - 가상 주소 - 실제 주소 변환 포함
  - 메모리 이외에
  - 각 프로세스에는 자체 페이지 테이블이 존재
  - 가상 페이지 번호로 인덱싱 
  - 페이지 테이블 엔트디(PTE)
    - 물리적 페이지 번호
    - 유효 비트 (또는 레지스 티스 비트 또는 존재 비트)
  - 페이지 테이블 레지스터
    - 페이지 테이블의 시작 주소



### 페이지 실패

- 유효 비트가 0일때 발생
- OS가 제어할 수있게 예외가 주어져야함
- 다음 단계에서 페이지를 찾고 요청 된 페이지를 메모리에 저장할 위치를 결정
- 

### 페이지 오류 처리

1. 페이지 폴트 예외로 OS를 트랩
2. 사용자 레지스터와 프로그램 상태를 저장
3. 예외가 페이지 폴트 였는지 확인
4. 참조가 합법적인지 확인하고 디스크상의 페이지 위치를 결정
5. 선택 희생자가 페이지 교체 알고리즘을 사용하는 경우
   - 디스크에 더럽혀진 블록을 기록한 경우 디스크에 기록을 남겨 둡니다
6. 디스크에서 자유 디스크로 읽기를 기다립니다
7. 기다리는 동안 CPU가 다른 프로세스에 할당 될 수 있습니다
8. 디스크에서 인터럽트가 완료되었습니다
9. 저장 다른 사용자의 레지스터와 프로그램 상태
10. 인터럽트가 디스크에서 발생했는지 확인
11. 페이지 테이블을 수정합니다 (원하는 페이지가 현재 메모리에 있음) 
12. CPU가이 프로세스에 다시 할당되도록 대기합니다.
13. 복구 사용자 레지스터, 프로그램 상태 및 새 페이지 테이블을 작성한 다음 인터럽트 된 명령을 다시 시작합니다

