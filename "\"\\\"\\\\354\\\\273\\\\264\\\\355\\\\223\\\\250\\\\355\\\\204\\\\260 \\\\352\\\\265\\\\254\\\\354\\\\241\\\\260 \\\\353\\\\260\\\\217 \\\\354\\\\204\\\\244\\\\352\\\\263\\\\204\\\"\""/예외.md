



# 컴퓨터 구조

## 예외

- 누가 실행중인 프로그램을 멈출 수 있는가?
  프로세서에서 실행중인 프로그램을 누가 바꿀 수 있는가?
  - 소프트웨어는 불가능하지만 하드웨어 제어 신호는 그렇다
  - 일반적으로 제어 신호는 프로세서에서 지정된 실행중인 프로그램으로 생성된다
  - 그래서, 우리는 실행중인 프로그램과는 독립적인 제어 신호가 필요하다
  - 정상적인 프로그램 흐름을 따르는 대신 프로세서가 지정된 주소에서 명령을 실행하도록 한다
- 예외와 인터럽트
  - 명령 실행의 정상 흐름을 변경하는 분기 또는 점프 이외의 이벤트
  - 제어의 흐름 변화를 요구하는 기대하지 않는 이벤트
  - 하드웨어가 함수 호출을 발생시킨다



### 예외와 인터럽트

- 예외
  - 프로그램 실행을 방해하는 예정되지 않은 이벤트
- 인터럽트
  - 프로세서 외부에서 발생하는 예외

| 이벤트의 타입                                 | 어디서 오는가? | MIPS 용어          |
| --------------------------------------------- | -------------- | ------------------ |
| I/O device request                            | 외부           | 인터럽트           |
| Invoke the operating system from user program | 내부           | 예외               |
| Arithmetic overflow                           | 내부           | 예외               |
| Using an undefined instruction                | 내부           | 예외               |
| Hardware malfunctions                         | 외부           | 예외 또는 인터럽트 |



### 예외의 원인

- 비동기 (외부 인터럽트)
  - 입/출력 기기 서비스에서 요청
  - 타이머 만료
  - 정전
  - 하드웨어 오작동
- 동기 (내부 예외 = 함정)
  - 정의 되지 않는 opcode
  - 권한 있는 명령어, 보호 위반
  - 산술 오버플로
  - 정렬되지 않은 메모리 액세스
  - 가상 메모리 예외
    - 페이지 오류, TLB 누락, 보호 위반
  - 소프트웨어 예외
    - 시스템 호출 ... SVC 또는 int 명령어



### MIPS 아키텍처에서 예외가 처리되는 방법

- MIPS에서 시스템 제어 코프로세서 (CP0)가 예외를 관리한다

1. 문제가 되는 (또는 중단 된) 명령의 주소 + 4 저장
   - MPIS에서 예외 프로그램 카운터(EPC) <- PC + 4
2. 특정 주소의 OS로 제어 전송
   - 원인 레지스터를 읽고 관련 처리기로 전송
3. OS가 적절한 조치를 취한다
   - 만약 재시작 가능하면
     - 적합한 행동을 한다
     - EPC를 이용해 프로그램으로 돌아 간다
   - 그렇지 않으면
     - 프로그램을 종료한다
     - EPC, 원인을 이용하여 에러를 보고한다.



### 예외에 대한 이유 전달

- 비 벡터 예외 (폴드 입터럽트)
  - 모든 인터럽트가 공유하는 단일 인터럽트 처리기
  - 인터럽트 처리기의 폴링
  - 그런 다음 장치의 서비스의 루틴으로 이동
- 백터 예외
  - 인터럽트 벡터
    - 인터럽트 핸들러의 메모리 주소 또는 인터럽트 벡터 테이블의 인덱스 (x86의 인터럽트 설명자 테이블)
  - 인터럽트 장치가 CPU에 인터럽트 벡터를 제공
  - 인터럽트 벡터는 인터럽트에 대한 처리기 루틴의 주소를 생성하는 데 사용



### 하드웨어 및 OS의 책임

- 하드웨어는 적절한 PC와 상태 플래그를 저장한다

- 하드웨어가 모든 인터럽트를 비활성화한다

- 하드웨어는 인터럽트의 원인을 찾는다 (벡터)

- 하드웨어는 새로운 PC와 플레그를 적재한다

- OS는 레지스터와 인터럽트 마스크를 저장한다

- OS는 인터럽트의 원인을 결정한다(찾는다) (non vector)

- OS는 인터럽트를 활성화 한다

- OS는 인터럽트를 서비스한다 => ISR (인터럽트 서비스 루틴)

- OS는 레지스터와 인터럽트 마스크를 복원한다

- OS는 인터럽트 복귀 명령을 실행하여 저장된 PC 및 플래그 값을 적재한다

   

### 인터럽트 설명자

- 인터럽트 설명 테이블 (IDT)
  - 인터럽트 벡터 테이블
  - 최대 256 개의 인터럽트 벡터, 8 바이트/벡터 -> 2KB
  - 0x0과 0x1F 사이의 INT_NUM은 예외를 위해 예약되어 있음
- IDT 기반 레지스터 (IDTR)
  - 실제 기본 주소와 IDT의 길이 저장
- int x 명령어
  - 소프트웨어 인터럽트 생성
  - x = 인터럽트 번호 (0 ~ 255)



### MIPS 인터럽트

- 비 벡터 인터럽트

  - 상태 레지스터(e.g. 원인 레지스터)를 사용
  - PC <- 8000 0180

  |     31      | ...  |     15~8      | ...  |    6~2    |
  | :---------: | :--: | :-----------: | :--: | :-------: |
  | 분기 딜레이 |      | 인터럽드 팬딩 |      | 예외 코드 |



### 명령어를 통한 병렬 처리

- 명령어 수준 병렬 처리 (ILP)
  - 여러 명령어를 병렬로 실행
  - 컴퓨터 프로그램에서 얼마나 많은 작업을 수행 할 수 있는지 측정
- 정적 다중 문제
  - 매우 큰 명령어 워드(VLIW)
  - 명시적 병렬 명령어 컴퓨터 (EPIC)

- 동적 다중 문제
  - 슈퍼 스칼라 프로세서
  - 동적 파이프라인 스케줄링
  - OOO (out-of-order(주문 외)) 실행