# 컴퓨터 구조

## 직접 사상 캐쉬

- 각각의 메모리 위치는 정확히 한 캐쉬 위치로 매핑됨
  - 많은 하위 레벨 블록은 캐시에서 블록을 공유
- 캐쉬 주소 (i.e 색인)
  - (블록 주소) 모듈로 (캐시의 블록 수)
- 캐시의 엔트리 수가 2 N 일 때,
  - 캐쉬 주소 = 하위 N 비트의 메모리 주소
- 캐시 라인의 필드
  - 유효 비트
  - 데이터
  - 태그
    - 원래 위치를 식별하는 데 필요한 정보
    - 색인을 제외한 메모리 주소의 고차원 부분
      

### 1- 워드 블록 캐시

- 32 비트 주소
- 1 워드 블록으로 구성된 2^n 개의 블록
- 바이트 오프셋
  - 하위 2 비트 (캐쉬 내에서 사용되지 않는)
- 색인
  - 다음 n비트
- 태그
  - 32 - (n + 2) 비트
- 총 비트 수
  - 2^n x (유효 비트 + 태그 + 블록 크기)
  - = 2^n × (1 + 32 - (n + 2) + 32)
  - = 2^n × (64 - n)



### 2^m- 워드 블록 캐시

- 32 비트 주소
- 2^m 워드 블록으로 구성된 2^n 개의 블록
- 바이트 오프셋: 2 비트
- 블락 오프셋: m 비트
- 색인: n비트
- 태그: 32 - (n + m + 2) 비트
- 총 비트 수
  - 2^n x (블록 크기 + 태그 크기 + 유효 자리 크기)
  - = 2^n × (2^m*32 + 32 - (n + m + 2) + 1)
  - = 2^n × (2^m*32 + 31 - n - m)



### 실패 비율 vs 블록 크기

- 거대한 블록
  - 증가된 공간적 지역성
  - 감소된 실패 비율
  - 그러나? 상호 충돌이 발생하여 실패율의 향상은 둔화됨



### 블록 크기 vs 성능

- 너무 큰 블록
  - 캐시의 블록 수가 적음
    - 증가 된 실패 비율
  - 증가 된 실패 비율
- 실패 벌칙
  - 실패 페널티 = 블록 인출 시간 + 캐시 로드 시간
  - 블록 가져 오기 시간 = 첫 워드 대기 시간 + 블록의 나머지 부분에 대한 전송 시간
  - 블록 크기가 커짐에 따라 전송 시간이 증가
  - 실패 패널티는 블록 크기가 증가함에 따라 증가



### 캐쉬 실패의 처리

- 명령어 캐쉬 실패 처리
  1. 원래의 PC값(PC-4)를 메모리로 보낸다
  2. 메인 메모리에서 읽기 동작을 지시하고 메모리가 접근을 끝낼 때까지 기다린다.
  3. 메모리에서 인출한 데이터를 데이터 부분에 쓰고 테그 필드에 주소(ALU로 부터 계산된)의 상위 비트를 쓰고 유효 비트를 1로 만듦으로써 캐시 엔트리에 쓰기를 수행한다
  4. 명령어 수행을 첫 단계부터 다시 시작하여 캐시에서 명령어를 가져온다. 이제는 필요한 명령어를 캐시에서 찾을 수 있다.
- 데이터 캐쉬 실패 처리
  - 메모리가 데이터를 보내 줄때까지 프로세서를 지연 시킨다.



### 쓰기의 처리

- 즉시 쓰기 정책
  - 항상 데이터를 메모리와 캐시에 같이 쓴다
  - 메모리와 캐쉬의 동일함을 보장한다
- 히트일때 쓰기
  1. 캐쉬 블록속 워드에 쓴다
  2. 또한 메모리에 있는 워드에 쓴다
- 실패일때 쓰기
  1. 워드를 포함하고 있는 블럭을 가져온다 
  2. 캐쉬 블록속 워드에 쓴다
  3. 또한 메모리에 있는 워드에 쓴다



### 즉시 쓰기의 문제

- 성능 저하
  - 모든 쓰기가 메인 메모리의 데이터를 사용해야 한다
  - 기계를 상당히 느리게 한다
- 해결책: 쓰기 버퍼
  - 메모리에 쓸 데이터를 가지고 있는다
  - CPU는 즉시 계속 작동한다
    - 오직 쓸 버퍼가 가득 찾을때만 멈춘다



### 나중 쓰기

- 새로운 값은 오직 캐쉬에서만 쓰여진다
  - 더러운 비트 또는 변경된 비트
- 변경된 블록은 그것이 대채될때 메인 메모리에 쓰여진다
- 더 높은 성능
- 더 복잡한 구현 