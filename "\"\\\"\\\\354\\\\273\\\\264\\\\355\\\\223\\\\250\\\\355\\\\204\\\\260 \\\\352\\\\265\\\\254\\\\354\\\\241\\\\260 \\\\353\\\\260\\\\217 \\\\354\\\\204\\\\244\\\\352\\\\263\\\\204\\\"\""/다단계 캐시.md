# 컴퓨터 구조

## 다단계 캐시

### 바꿀 블록 선택하기

- 재배치 알고리즘
  - 직접 매핑 된 캐시 ... 고유하게 지정
  - 연관 집합 캐시 ... 집합 내의 블록 중에서 선택
  - 완전 연관 캐시 ... 모든 블록 중에서 선택
- LRU (가장 최근에 사용되지 않은)
  - 가장 긴 시간동안 사용되지 않은 블록을 쫒아냄
  - 구현
    - 각 요소가 언제 사용되었는지를 추적
  - 2-way 연관 집합 캐시
    - 1 참조 비트
  - 높은 연관성 등급 
    - 구현하기 어렵다



### 다단계 캐시를 이용한 실패 손실 줄이기

- 1차 캐시
  - 독립 칩
- 2 차 캐시
  - 1 차 캐시에 실패가 발생할 때마다 독립 칩에 접근
  - 1 차 캐시의 실패 손실 감소
- 예 : 다중 레벨 캐시 성능 
  - 클록 속도 = 4 GHz 
  - 1 차 캐시에서의 CPI = 1.0 100 % 히트률
  - 주요 메모리 액세스 시간 = 100 ns (미스 처리 포함)
  -  1 차 캐시에서의 속도 / 명령 = 2 % 
  - 아래의 2 차 캐시로 어떻게 더 빨라지나요?
    - 글로벌 실패율 = 0.5 %, 액세스 시간 = 5ns
  - 1차 캐시
    - 메인 메모리의 실패 손실 = 100ns/0.25ns = 400 clock cycles 
    - 전체 CPI = base CPI + memory-stall cycles per instruction = 1.0 + 2% x 400 = 9.0
  - 2차 캐시
    - 두번째 캐시에서 실패 손실 = 5ns/0.25ns = 20 clock cycles 
    - 전체 CPI = 1 + primary stalls + secondary stalls = 1 + 2% x 20 + 0.5% x 400 = 3.4
  - 그러므로 속도 상승 = 9.0/3.4 = 2.6



### 1 차 및 2 차 캐시 설계시 고려 사항

- 1차 캐시 
  -  최소 성공 시간에 집중
    - 더 짧은 클럭 사이클 또는 더 적은 파이프 라인 스테이지를 산출
  - 작은 캐시
  - 작은 블록 크기 -> 실패률 줄이기
- 2차 캐시
  - 실패율 줄이기에 집중
    - 메모리 접근에 긴 시간이 필요한 손실을 줄임
  - 큰 캐시
    - 접근 시간이 덜 중요하기 때문에
  - 큰 블록 크기와 높은 연관성
    - 실패율을 줄이기 위해



### 요약: 캐시 성능 향상

1. 캐시 성공에 걸리는 시간 줄이기
   - 작은 캐시
   - 직접 사상 캐시
   - 작은 블록
2. 실패율 줄이기
   - 더 큰 캐시
   - 더 유연한 배치 (연관성 증가)
   - 더 큰 블록 (일반적으로 16 - 64 바이트)
   - victim 캐시 - 가장 최근에 버려진 블록을 유지하는 작은 버퍼
3. 실패 손실 줄이기
   - 더 작은 블록
   - 더티 블록을 교체하기 위해 쓰기 버퍼를 사용은 읽기 전에 쓰기가 완료 될 때까지 기다릴 필요가 없다.
   - 읽기 실패시 쓰기 버퍼 (및 / 또는 희생 캐시)를 확인
   - 중요한 단어를 먼저 사용
   - 여러 캐시 레벨 - CPU 클럭 속도와 무관 한 L2 캐시
   - 빠른 백업 저장소 / 향상된 메모리 대역폭
     - 넓은 버스
     - 메모리 인터리빙, DDR SDRAM

- 여러 상호 작용하는 차원
  - 캐시 크기
  - 블록 크기 
  - 연관성 
  - 대체 정책 
  - 바로 쓰기  vs 나중 쓰기
  - 쓰기 할당 
- 최적의 선택은 타협
  - 액세스 특성에 따른 차이
    - 작업 부하
    - 사용 (I- 캐시, D- 캐시, TLB )
  - 기술 / 비용상의 차이
- 단순성이 종종 승리 함



### 캐시를 지원하도록 메모리 시스템 설계

- 메모리에서 캐시로의 대역폭 증가
  - 미스 페널티 감소
  - 큰 블록 크기의 미스 페널티 감소
- 버스
  - 프로세서에 메모리 연결
  - 프로세서보다 훨씬 느림 10 배까지
- 요구 사항
  - 메모리 버스 클럭 사이클 1 개 주소 
  - 시작된 각 DRAM 액세스에 대해 15 클럭 사이클
  - 데이터 워드를 보내기위한 1 클록 사이클
  - 4 워드의 캐시 블록



### 한 단어로 된 메모리

- 1 워드 폭의 DRAM 뱅크
- 모든 액세스는 순차적으로 이루어짐
- 실패 손실
  - 1 + 4 x 15 + 4 x 1 = 65 (클럭 사이클) 
- 한 실패를 위해 한 클럭 사이클 동안 전송 된 바이트 수  
  - (4 x 4) / 65 = 0.25 (바이트 / 사이클) 



### 와이드 메모리  

- 메모리와 버스를 확장하여 메모리 대역폭을 증가
  - 블록의 모든 워드에 대한 병렬 접근.
- 주요 비용
  - 넓은 버스
  - 프로세서 및 캐시 간의 멀티플렉서 및 콘택 스트에 액세스하는 잠재적 인 증가

- 기본 메모리 너비 = 2 워드
  - 실패율 = 1 + 2x15 + 2x1 = 33 (클럭 사이클)
  - 광대역에 대한 단일 대역폭 = 4x4 / 33 = 0.48 (바이트 / 사이클)
-  메모리 대역폭 = 4 워드
  - 실패율 = 1 + 1x15 + 1x1 = 17 (클럭 사이클)
  - 광대역 단일 전송 = 4x4 / 17 = 0.94 (바이트 / 사이클)
    

### 삽입형 메모리

- 버스 및 캐시는 제외한 메모리를 넓인다
- 뱅크의 메모리 칩을 구성하여 한 번의 액세스 시간에 여러 단어를 읽거나 쓴다
- 전체 메모리 대기 시간은 한 번만 발생한다
- 각 뱅크는 독립적으로 쓸 수 있다
  - 쓰기 대역폭의 4 배입니다
  - 바로 쓰기 캐시에서 지연이 발생합니다.

- 4 뱅크
  - 4-way interleaved memory
  - 실패 손실 = 1 + 1x15 + 4x1 = 20 (clock cycles)
  - Bandwidth for a single miss = 4x4 / 20 = 0.80
      